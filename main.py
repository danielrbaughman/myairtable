from pathlib import Path
from typing import Annotated

import pyperclip
from rich import print
from typer import Argument, Option, Typer

from src import timer
from src.csv import generate_csv
from src.helpers import create_folder, reset_folder
from src.markdown import generate_markdown
from src.meta import Base, generate_meta, get_base_meta_data
from src.python import generate_python
from src.typescript import generate_typescript

app = Typer()


def setup_benchmark(benchmark: bool):
    """Enable timing if benchmark flag is set."""
    if benchmark:
        timer.enable()
        timer.reset()


@app.command()
def meta(
    folder: Annotated[str, Argument(help="Path to the output folder")],
):
    """Fetch Airtable metadata into a json file."""
    metadata = get_base_meta_data()
    folder_path = Path(folder)
    folder_path.mkdir(parents=True, exist_ok=True)
    generate_meta(metadata=metadata, folder=folder_path)


@app.command()
def csv(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
):
    """Export Airtable metadata to CSV format."""
    folder_path = reset_folder(Path(folder))
    base = Base(csv_folder=folder_path)
    generate_csv(base=base, folder=folder_path, fresh=fresh)


@app.command()
def py(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    csv_folder: Annotated[str, Option(help="Path to the folder containing the CSV generated by the `csv` command.")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
    formulas: Annotated[bool, Option(help="Include formula-helper classes in the output.")] = True,
    wrappers: Annotated[bool, Option(help="Include wrapper classes for tables and base in the output.")] = True,
    package_prefix: Annotated[str, Option(help="Use if the code is not generated at the root level of the package")] = "",
    benchmark: Annotated[bool, Option(help="Enable detailed performance timing.")] = False,
):
    """Generate types and models in Python"""
    setup_benchmark(benchmark)

    folder_path = reset_folder(Path(folder))
    csv_folder_path = Path(csv_folder) if csv_folder else folder_path

    base = Base(csv_folder=csv_folder_path)

    if fresh:
        with timer.timer("CSV generation"):
            generate_csv(base=base, folder=csv_folder_path, fresh=True)

    with timer.timer("Python generation"):
        generate_python(
            base=base,
            output_folder=folder_path,
            formulas=formulas,
            wrappers=wrappers,
            package_prefix=package_prefix,
        )

    timer.summary()


@app.command()
def ts(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    csv_folder: Annotated[str, Option(help="Path to the folder containing the CSV generated by the `csv` command.")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
    formulas: Annotated[bool, Option(help="Include formula-helper classes in the output.")] = True,
    wrappers: Annotated[bool, Option(help="Include wrapper classes for tables and base in the output.")] = True,
):
    """Generate types and models in TypeScript"""
    folder_path = reset_folder(Path(folder))
    csv_folder_path = Path(csv_folder) if csv_folder else folder_path
    base = Base(csv_folder=csv_folder_path)
    if fresh:
        generate_csv(base=base, folder=csv_folder_path, fresh=True)
    generate_typescript(base=base, output_folder=folder_path, formulas=formulas, wrappers=wrappers)


@app.command()
def md(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    benchmark: Annotated[bool, Option(help="Enable detailed performance timing.")] = False,
    svg: Annotated[bool, Option("--svg/--no-svg", help="Generate SVG diagrams for formula fields.")] = True,
    reset_svg_cache: Annotated[bool, Option(help="Reset the SVG cache")] = False,
    format_formulas: Annotated[bool, Option("--format-formulas/--no-format-formulas", help="Format formulas for better readability.")] = True,
    flatten_formulas: Annotated[
        bool, Option("--flatten-formulas/--no-flatten-formulas", help="Show flattened formulas with nested references expanded.")
    ] = True,
    mermaid_formulas: Annotated[
        bool, Option("--mermaid-formulas/--no-mermaid-formulas", help="Generate Mermaid diagrams for formula fields.")
    ] = True,
):
    """Generate Markdown documentation for the base. Intended for use in Obsidian."""
    setup_benchmark(benchmark)

    preserve = None if reset_svg_cache else [".svg_cache"]
    folder_path = reset_folder(Path(folder), preserve=preserve)

    base = Base()

    with timer.timer("Markdown generation"):
        generate_markdown(
            base=base,
            output_folder=folder_path,
            svg_enabled=svg,
            format_formulas=format_formulas,
            flatten_formulas=flatten_formulas,
            mermaid_formulas=mermaid_formulas,
        )

    timer.summary()


@app.command()
def invalid():
    """Check for invalid fields"""
    base = Base()
    check_invalid(base)


def check_invalid(base: Base) -> None:
    print("Checking for invalid fields")
    invalid_found = False
    for table in base.tables:
        for field in table.fields:
            if not field.is_valid():
                print(f"[dim] - Table '{table.name}', Field '{field.name}' ({field.id})[/]")
                invalid_found = True
    if not invalid_found:
        print("[green] - No invalid fields found.[/]")
    else:
        print("[yellow] - Invalid fields detected.[/]")
    print("")


@app.command()
def formula(
    field_id: Annotated[str, Argument(help="The ID of the formula field")],
    sanitize: Annotated[bool, Option(help="Replace field IDs with field names in the formula.")] = True,
    flatten: Annotated[bool, Option(help="Expand all nested formula field references.")] = False,
    format: Annotated[bool, Option(help="Format the formula for better readability.")] = False,
    highlight: Annotated[bool, Option(help="Highlight the formula syntax (outputs as HTML).")] = False,
):
    """Copy the formula of a formula field to the clipboard."""
    base = Base()
    for table in base.tables:
        for field in table.fields:
            if field.id == field_id:
                if field.type == "formula":
                    print(f"[green]Formula for field '{field.name}' ({field.id}):[/]")
                    formula = field.formula(sanitized=sanitize, flatten=flatten, format=format, highlight=highlight)
                    print(formula)
                    pyperclip.copy(formula)
                    print("[blue]Formula copied to clipboard.[/]")
                    return
                else:
                    print(f"[red]Field '{field.name}' ({field.id}) is not a formula field.[/]")
                    return
    print(f"[red]Field with ID '{field_id}' not found.[/]")


@app.command()
def all(
    meta_folder: Annotated[str, Option(help="Path to the folder containing the generated JSON.")] = "",
    csv_folder: Annotated[str, Option(help="Path to the folder containing the generated CSV.")] = "",
    py_folder: Annotated[str, Option(help="Path to the Python output folder")] = "",
    ts_folder: Annotated[str, Option(help="Path to the TypeScript output folder")] = "",
    md_folder: Annotated[str, Option(help="Path to the Markdown output folder")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
    formulas: Annotated[bool, Option(help="Include formula-helper classes in the output.")] = True,
    wrappers: Annotated[bool, Option(help="Include wrapper classes for tables and base in the output.")] = True,
    py_package_prefix: Annotated[str, Option(help="Use if the code is not generated at the root level of the package")] = "",
    benchmark: Annotated[bool, Option(help="Enable detailed performance timing.")] = False,
    svg: Annotated[bool, Option("--svg/--no-svg", help="Generate SVG diagrams for formula fields in markdown.")] = True,
    reset_svg_cache: Annotated[bool, Option(help="Reset the SVG cache when regenerating markdown.")] = False,
    format_formulas: Annotated[
        bool, Option("--format-formulas/--no-format-formulas", help="Format formulas for better readability in markdown.")
    ] = True,
    flatten_formulas: Annotated[bool, Option("--flatten-formulas/--no-flatten-formulas", help="Show flattened formulas in markdown.")] = True,
    mermaid_formulas: Annotated[
        bool, Option("--mermaid-formulas/--no-mermaid-formulas", help="Generate Mermaid diagrams for formula fields in markdown.")
    ] = True,
):
    """Generate json, CSV, Python, and TypeScript code."""
    setup_benchmark(benchmark)

    csv_folder_path = create_folder(csv_folder) if csv_folder else None

    base = Base(csv_folder=csv_folder_path)

    if meta_folder:
        with timer.timer("Meta generation"):
            meta_folder_path = create_folder(meta_folder)
            generate_meta(metadata=base.to_dict(), folder=meta_folder_path)
    if csv_folder_path:
        with timer.timer("CSV generation"):
            generate_csv(base=base, folder=csv_folder_path, fresh=fresh)
    if py_folder:
        with timer.timer("Python generation"):
            py_folder_path = reset_folder(py_folder)
            generate_python(
                base=base,
                output_folder=py_folder_path,
                formulas=formulas,
                wrappers=wrappers,
                package_prefix=py_package_prefix,
            )
    if ts_folder:
        with timer.timer("TypeScript generation"):
            ts_folder_path = reset_folder(ts_folder)
            generate_typescript(base=base, output_folder=ts_folder_path, formulas=formulas, wrappers=wrappers)
    if md_folder:
        with timer.timer("Markdown generation"):
            preserve = None if reset_svg_cache else [".svg_cache"]
            md_folder_path = reset_folder(md_folder, preserve=preserve)
            generate_markdown(
                base=base,
                output_folder=md_folder_path,
                svg_enabled=svg,
                format_formulas=format_formulas,
                flatten_formulas=flatten_formulas,
                mermaid_formulas=mermaid_formulas,
            )
    check_invalid(base)
    print("[green]Generation complete.[/]")

    timer.summary()
    print("")


if __name__ == "__main__":
    from dotenv import load_dotenv

    load_dotenv()
    app()
