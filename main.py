from pathlib import Path
from typing import Annotated

import pyperclip
from rich import print
from typer import Argument, Option, Typer

from src.csv import generate_csv
from src.helpers import create_folder, reset_folder
from src.markdown import generate_markdown
from src.meta import Base, generate_meta, get_base_meta_data
from src.python import generate_python
from src.typescript import generate_typescript

app = Typer()


@app.command()
def meta(
    folder: Annotated[str, Argument(help="Path to the output folder")],
):
    """Fetch Airtable metadata into a json file."""
    metadata = get_base_meta_data()
    folder_path = Path(folder)
    folder_path.mkdir(parents=True, exist_ok=True)
    generate_meta(metadata=metadata, folder=folder_path)


@app.command()
def csv(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
):
    """Export Airtable metadata to CSV format."""
    folder_path = reset_folder(Path(folder))
    base = Base.new(csv_folder=folder_path)
    generate_csv(base=base, folder=folder_path, fresh=fresh)


@app.command()
def py(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    csv_folder: Annotated[str, Option(help="Path to the folder containing the CSV generated by the `csv` command.")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
    formulas: Annotated[bool, Option(help="Include formula-helper classes in the output.")] = True,
    wrappers: Annotated[bool, Option(help="Include wrapper classes for tables and base in the output.")] = True,
    package_prefix: Annotated[str, Option(help="Use if the code is not generated at the root level of the package")] = "",
):
    """Generate types and models in Python"""
    folder_path = reset_folder(Path(folder))
    csv_folder_path = Path(csv_folder) if csv_folder else folder_path
    base = Base.new(csv_folder=csv_folder_path)
    if fresh:
        generate_csv(base=base, folder=csv_folder_path, fresh=True)
    generate_python(
        base=base,
        output_folder=folder_path,
        formulas=formulas,
        wrappers=wrappers,
        package_prefix=package_prefix,
    )


@app.command()
def ts(
    folder: Annotated[str, Argument(help="Path to the output folder")],
    csv_folder: Annotated[str, Option(help="Path to the folder containing the CSV generated by the `csv` command.")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
):
    """Generate types and models in TypeScript"""
    folder_path = reset_folder(Path(folder))
    csv_folder_path = Path(csv_folder) if csv_folder else folder_path
    base = Base.new(csv_folder=csv_folder_path)
    if fresh:
        generate_csv(base=base, folder=csv_folder_path, fresh=True)
    generate_typescript(base=base, output_folder=folder_path)


@app.command()
def md(folder: Annotated[str, Argument(help="Path to the output folder")]):
    """Generate Markdown documentation for the base. Intended for use in Obsidian."""
    folder_path = reset_folder(Path(folder))
    base = Base.new()
    generate_markdown(base=base, output_folder=folder_path)


@app.command()
def invalid():
    """Check for invalid fields"""
    base = Base.new()
    check_invalid(base)


def check_invalid(base: Base) -> None:
    print("Checking for invalid fields")
    invalid_found = False
    for table in base.tables:
        for field in table.fields:
            if not field.is_valid():
                print(f"[dim] - Table '{table.name}', Field '{field.name}' ({field.id})[/]")
                invalid_found = True
    if not invalid_found:
        print("[green] - No invalid fields found.[/]")
    else:
        print("[yellow] - Invalid fields detected.[/]")
    print("")


@app.command()
def formula(
    field_id: Annotated[str, Argument(help="The ID of the formula field")],
    sanitize: Annotated[bool, Option(help="Replace field IDs with field names in the formula.")] = True,
    flatten: Annotated[bool, Option(help="Expand all nested formula field references.")] = False,
    format: Annotated[bool, Option(help="Format the formula for better readability.")] = False,
    highlight: Annotated[bool, Option(help="Highlight the formula syntax (outputs as HTML).")] = False,
):
    """Copy the formula of a formula field to the clipboard."""
    base = Base.new()
    for table in base.tables:
        for field in table.fields:
            if field.id == field_id:
                if field.type == "formula":
                    print(f"[green]Formula for field '{field.name}' ({field.id}):[/]")
                    formula = field.formula(sanitized=sanitize, flatten=flatten, format=format, highlight=highlight)
                    print(formula)
                    pyperclip.copy(formula)
                    print("[blue]Formula copied to clipboard.[/]")
                    return
                else:
                    print(f"[red]Field '{field.name}' ({field.id}) is not a formula field.[/]")
                    return
    print(f"[red]Field with ID '{field_id}' not found.[/]")


@app.command()
def all(
    meta_folder: Annotated[str, Option(help="Path to the folder containing the generated JSON.")] = "",
    csv_folder: Annotated[str, Option(help="Path to the folder containing the generated CSV.")] = "",
    py_folder: Annotated[str, Option(help="Path to the Python output folder")] = "",
    ts_folder: Annotated[str, Option(help="Path to the TypeScript output folder")] = "",
    md_folder: Annotated[str, Option(help="Path to the Markdown output folder")] = "",
    fresh: Annotated[bool, Option(help="Generate fresh property names instead of using custom names if they exist.")] = False,
    formulas: Annotated[bool, Option(help="Include formula-helper classes in the output.")] = True,
    wrappers: Annotated[bool, Option(help="Include wrapper classes for tables and base in the output.")] = True,
    py_package_prefix: Annotated[str, Option(help="Use if the code is not generated at the root level of the package")] = "",
):
    """Generate json, CSV, Python, and TypeScript code."""
    csv_folder_path = create_folder(csv_folder) if csv_folder else None
    base = Base.new(csv_folder=csv_folder_path)

    if meta_folder:
        meta_folder_path = create_folder(meta_folder)
        generate_meta(metadata=base.to_dict(), folder=meta_folder_path)
    if csv_folder_path:
        generate_csv(base=base, folder=csv_folder_path, fresh=fresh)
    if py_folder:
        py_folder_path = reset_folder(py_folder)
        generate_python(
            base=base,
            output_folder=py_folder_path,
            formulas=formulas,
            wrappers=wrappers,
            package_prefix=py_package_prefix,
        )
    if ts_folder:
        ts_folder_path = reset_folder(ts_folder)
        generate_typescript(base=base, output_folder=ts_folder_path)
    if md_folder:
        md_folder_path = reset_folder(md_folder)
        generate_markdown(base=base, output_folder=md_folder_path)
    check_invalid(base)
    print("[green]Generation complete.[/]")
    print("")


if __name__ == "__main__":
    from dotenv import load_dotenv

    load_dotenv()
    app()
